diff --git a/__pycache__/delaunay.cpython-38.pyc b/__pycache__/delaunay.cpython-38.pyc
index b97125d..af2cf0e 100644
Binary files a/__pycache__/delaunay.cpython-38.pyc and b/__pycache__/delaunay.cpython-38.pyc differ
diff --git a/chew.py b/chew.py
index d95a507..5792183 100644
--- a/chew.py
+++ b/chew.py
@@ -42,6 +42,7 @@ def angle(a,b):
     return np.arccos(np.dot(a,b) / (length(a) * length(b)))
 
 def met_req(tri, faces, verts):
+    #TODO: verificar se ângulo é formado por arestas de restrição
     a = np.asarray(verts[tri[0]-1]) - np.asarray(verts[tri[1]-1])
     b = np.asarray(verts[tri[1]-1]) - np.asarray(verts[tri[2]-1])
     c = np.asarray(verts[tri[2]-1]) - np.asarray(verts[tri[0]-1])
@@ -64,7 +65,39 @@ def circumcenter(a, b, c):
     uy = ((a[0] * a[0] + a[1] * a[1]) * (c[0] - b[0]) + (b[0] * b[0] + b[1] * b[1]) * (a[0] - c[0]) + (c[0] * c[0] + c[1] * c[1]) * (b[0] - a[0])) / d
     return (ux, uy, 0)
 
-def chew(faces, corners, verts, ax1):    
+def inside_triangulation(pr, tri, faces, verts, corners, ax):
+    a = verts[tri.tri[0]-1]
+    b = verts[tri.tri[1]-1]
+    c = verts[tri.tri[2]-1]
+
+    cs = delaunay.find_tri_corners(tri.index-1, corners)
+    border = False
+    for corner in cs:
+        if corner.c_o == -1:
+            border = True
+            break
+
+    if border and not delaunay.inside(pr, verts, corners, faces)[0]:
+        distAB = length(np.asarray(a) + ((np.asarray(b) - np.asarray(a))/2) - np.asarray(pr))
+        distBC = length(np.asarray(b) + ((np.asarray(c) - np.asarray(b))/2) - np.asarray(pr))
+        distCA = length(np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2) - np.asarray(pr))
+
+        if distAB < distBC:
+            if distAB < distCA:
+                #AB é menor retorna o ponto médio
+                 return False, np.asarray(a) + ((np.asarray(b) - np.asarray(a))/2)
+            else:
+                #CA é menor retorna o ponto médio
+                return False, np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2)
+        elif distBC < distCA:
+            #BC é menor retorna o ponto médio
+            return False, np.asarray(b) + ((np.asarray(c) - np.asarray(b))/2)
+        else:
+            #CA é menor retorna o ponto médio
+            return False, np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2)
+    return True, pr
+
+def chew(faces, corners, verts, ax1, arestas_restritas):    
     q = queue.PriorityQueue()
     
 
@@ -78,25 +111,18 @@ def chew(faces, corners, verts, ax1):
 
         pr = circumcenter(verts[tri.tri[0]-1], verts[tri.tri[1]-1], verts[tri.tri[2]-1])
 
-        verts.append(list(pr))
-        pr = len(verts)
-        pi, pj, pk = tri.tri
-        t1 = [pi, pj, pr]
-        t2 = [pr, pj, pk]
-        t3 = [pi, pr, pk]
-        faces.remove(tri.tri)
-        faces.append(t1)
-        if not met_req(t1,faces,verts):
-            q.put(PrioritizedTri(len(faces), t1, verts))
-        faces.append(t2)
-        if not met_req(t2,faces,verts):
-            q.put(PrioritizedTri(len(faces), t2, verts))
-        faces.append(t3)
-        if not met_req(t3,faces,verts):
-            q.put(PrioritizedTri(len(faces), t3, verts))
+        ax1.scatter(pr[0], pr[1], color='b')
+        plt.pause(0.05)
 
+        inside, pr = inside_triangulation(pr, tri, faces.copy(), verts, corners, ax1)
+
+        corners, faces = delaunay.add_point(pr, verts, corners, faces, arestas_restritas)
+        added_tris = [x for x in faces if len(verts) in x]
+        for t in added_tris:
+            if not met_req(t,faces,verts):
+                q.put(PrioritizedTri(faces.index(t), t, verts))
         # ax1.triplot(np.asarray(verts)[:,0], np.asarray(verts)[:,1], triangles = np.asarray(T[-3:])-1, color='r')
-        corners = corner_table.build_corner_table(faces)
+            
     return faces, corners, verts
 
 def plot_tri(faces, vertex, ax):
@@ -105,6 +131,8 @@ def plot_tri(faces, vertex, ax):
     ax.clear()
     ax.scatter(vertex[3:,0], vertex[3:,1], color='r')
     ax.triplot(vertex[:,0], vertex[:,1], triangles = faces, color='k')
+    for idx,x in enumerate(vertex):
+            plt.text(x[0], x[1], str(idx+1),color='g')
     plt.pause(0.05)
 
 def main ():
@@ -124,7 +152,7 @@ def main ():
 
         faces, corners, verts = delaunay.delaunay_triangulation(obj, arestas, ax1)
         faces, corners, verts = delaunay.delaunay_restriction(faces, corners, arestas, verts, ax1)
-        faces, corners, verts = chew(faces, corners, verts, ax1)
+        faces, corners, verts = chew(faces, corners, verts, ax1, arestas)
         plt.show()
 
 if __name__ == '__main__':
diff --git a/delaunay.py b/delaunay.py
index f64b303..9c2af60 100644
--- a/delaunay.py
+++ b/delaunay.py
@@ -13,7 +13,9 @@
 def find_tri_corners(idx, corners):
     return [corners[3*idx], corners[corners[3*idx].c_n - 1], corners[corners[3*idx].c_p - 1]]
 
-def inside(pr, verts, corners, T):
+def inside(pr, verts, corners, T, tri=None):
+    if tri != None:
+        T = tri
     for tri in T:
         tr_c = find_tri_corners(T.index(tri), corners)
 
@@ -23,13 +25,13 @@ def inside(pr, verts, corners, T):
         b = [1, pr[0], pr[1]]
 
         x = np.linalg.solve(A,b)
-        if abs(x[0]) < 10e-3:
+        if abs(x[0]) < 5e-3:
             #v2 e v3
             return False, tri, [tri[1], tri[2]]
-        elif abs(x[1]) < 10e-3:
+        elif abs(x[1]) < 5e-3:
             #v3 e v1
             return False, tri, [tri[2], tri[0]]
-        elif abs(x[2]) < 10e-3:
+        elif abs(x[2]) < 5e-3:
             #v1 e v2
             return False, tri, [tri[0], tri[1]]
         elif (x > 0).all():
@@ -108,74 +110,64 @@ def plot_tri(faces, vertex, ax1):
     ax1.triplot(vertex[:,0], vertex[:,1], triangles = faces, color='k')
     plt.pause(0.05)
 
-def delaunay_triangulation(obj, arestas_restritas, ax1):
-    vertex = np.array(obj.vertex)
-    faces = np.asarray(obj.faces)
+def add_point(pr, verts, corners, T, arestas_restritas):
+    # plot_tri(T.copy(), verts.copy(), ax1)
 
-    x_max, y_max, z_max = vertex.max(axis=0)
-    x_min, y_min, z_min = vertex.min(axis=0)
+    # ax1.scatter(pr[0],pr[1],color='r')
+    plt.pause(0.05)
+    ins, t, aresta = inside(pr, verts, corners, T)
+    if ins:
+        verts.append(list(pr))
+        pr = len(verts)
+        pi, pj, pk = t
+        t1 = [pi, pj, pr]
+        t2 = [pr, pj, pk]
+        t3 = [pi, pr, pk]
+        T.remove(t)
+        T.append(t1)
+        T.append(t2)
+        T.append(t3)
+        # ax1.triplot(np.asarray(verts)[:,0], np.asarray(verts)[:,1], triangles = np.asarray(T[-3:])-1, color='r')
+        corners = corner_table.build_corner_table(T)
 
-    pa = [2*x_min, 2*y_min, z_min]
-    pb = [2*x_max+abs(x_min), y_min, z_min]
-    pc = [x_min, 2*y_max+abs(y_min), z_min]
-    # print(x_min, y_min, z_min)
-    # print(x_max, y_max, z_max)
-    
-    verts = [pa,pb,pc]
-    T = [[1, 2, 3]]
-    corners = corner_table.build_corner_table(T)
-    for pr in reversed(vertex):
-        # plot_tri(T.copy(), verts.copy(), ax1)
-
-        # ax1.scatter(pr[0],pr[1],color='r')
-        plt.pause(0.05)
-        ins, t, aresta = inside(pr, verts, corners, T)
-        if ins:
-            verts.append(list(pr))
-            pr = len(verts)
-            pi, pj, pk = t
-            t1 = [pi, pj, pr]
-            t2 = [pr, pj, pk]
-            t3 = [pi, pr, pk]
+        corners = legalize_aresta(pr, [pi,pj], arestas_restritas, t1, T, corners, verts)
+        corners = legalize_aresta(pr, [pj,pk], arestas_restritas, t2, T, corners, verts)
+        corners = legalize_aresta(pr, [pk,pi], arestas_restritas, t3, T, corners, verts)
+    elif len(aresta) == 2:
+        verts.append(list(pr))
+        pr = len(verts)
+
+        if tuple(aresta) in arestas_restritas:
+            arestas_restritas.remove(tuple(aresta))
+            arestas_restritas.append(tuple(aresta[0], pr))
+            arestas_restritas.append(tuple(pr, aresta[1]))
+
+        pi, pj = aresta 
+
+        pk = np.asarray(t)
+        pk = np.delete(pk, np.where(pk==aresta[0]))
+        pk = list(np.delete(pk, np.where(pk==aresta[1])))[0]
+        
+        cs = find_tri_corners(find_tri_index(t, T), corners)
+
+        pl = -1
+        trian = len(T) + 1 
+        for c in cs:
+            if c.c_v == pk:
+                pl = -1 if c.c_o == -1 else corners[c.c_o - 1].c_v
+                trian = corners[c.c_o - 1].c_t
+                break
+        
+        if pl == -1:
+            t1 = [pi,pr,pk]
+            t2 = [pr,pj,pk]
             T.remove(t)
             T.append(t1)
             T.append(t2)
-            T.append(t3)
-
-            # ax1.triplot(np.asarray(verts)[:,0], np.asarray(verts)[:,1], triangles = np.asarray(T[-3:])-1, color='r')
+        
             corners = corner_table.build_corner_table(T)
 
-            corners = legalize_aresta(pr, [pi,pj], arestas_restritas, t1, T, corners, verts)
-            corners = legalize_aresta(pr, [pj,pk], arestas_restritas, t2, T, corners, verts)
-            corners = legalize_aresta(pr, [pk,pi], arestas_restritas, t3, T, corners, verts)
-        elif len(aresta) == 2:
-            verts.append(list(pr))
-            pr = len(verts)
-
-            if tuple(aresta) in arestas_restritas:
-                arestas_restritas.remove(tuple(aresta))
-                arestas_restritas.append(tuple(aresta[0], pr))
-                arestas_restritas.append(tuple(pr, aresta[1]))
-
-            pi, pj = aresta 
-
-            pk = np.asarray(t)
-            pk = np.delete(pk, np.where(pk==aresta[0]))
-            pk = list(np.delete(pk, np.where(pk==aresta[1])))[0]
-            
-            cs = find_tri_corners(find_tri_index(t, T), corners)
-    
-            pl = -1
-            trian = len(T) + 1 
-            for c in cs:
-                if c.c_v == pk:
-                    pl = -1 if c.c_o == -1 else corners[c.c_o - 1].c_v
-                    trian = corners[c.c_o - 1].c_t
-                    break
-            
-            if pl == -1:
-                return
-
+        else:
             t1 = [pj, pk, pr]
             t2 = [pk, pi, pr]
             t3 = [pi, pl, pr]
@@ -192,7 +184,27 @@ def delaunay_triangulation(obj, arestas_restritas, ax1):
             corners = legalize_aresta(pr, [pj, pk], arestas_restritas, t1, T, corners, verts)
             corners = legalize_aresta(pr, [pi, pk], arestas_restritas, t2, T, corners, verts)
             corners = legalize_aresta(pr, [pi, pl], arestas_restritas, t3, T, corners, verts)
-            corners = legalize_aresta(pr, [pl, pj], arestas_restritas, t4, T, corners, verts) 
+            corners = legalize_aresta(pr, [pl, pj], arestas_restritas, t4, T, corners, verts)
+    return corners, T
+
+def delaunay_triangulation(obj, arestas_restritas, ax1):
+    vertex = np.array(obj.vertex)
+    faces = np.asarray(obj.faces)
+
+    x_max, y_max, z_max = vertex.max(axis=0)
+    x_min, y_min, z_min = vertex.min(axis=0)
+
+    pa = [2*x_min, 2*y_min, z_min]
+    pb = [2*x_max+abs(x_min), y_min, z_min]
+    pc = [x_min, 2*y_max+abs(y_min), z_min]
+    # print(x_min, y_min, z_min)
+    # print(x_max, y_max, z_max)
+    
+    verts = [pa,pb,pc]
+    T = [[1, 2, 3]]
+    corners = corner_table.build_corner_table(T)
+    for pr in reversed(vertex):
+        corners, T = add_point(pr, verts, corners, T, arestas_restritas)
     # plot_tri(T.copy(), verts.copy(), ax1)
     #Remove supertriangle
     # copy_T = T.copy()

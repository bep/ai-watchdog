diff --git a/__pycache__/chew.cpython-38.pyc b/__pycache__/chew.cpython-38.pyc
new file mode 100644
index 0000000..3a4db8c
Binary files /dev/null and b/__pycache__/chew.cpython-38.pyc differ
diff --git a/__pycache__/delaunay.cpython-38.pyc b/__pycache__/delaunay.cpython-38.pyc
index af2cf0e..350b3f7 100644
Binary files a/__pycache__/delaunay.cpython-38.pyc and b/__pycache__/delaunay.cpython-38.pyc differ
diff --git a/arestas.in b/arestas.in
index 014d739..3fc3f60 100644
--- a/arestas.in
+++ b/arestas.in
@@ -1 +1,2 @@
-7,22,21,18
\ No newline at end of file
+19,22,22,18,18,16,16,14,14,10,10,4,4,5,5,6,6,19
+0.06306657711498222
diff --git a/chew.py b/chew.py
index 5792183..3a42127 100644
--- a/chew.py
+++ b/chew.py
@@ -1,3 +1,4 @@
+from numpy.lib.arraysetops import intersect1d
 import obj as OBJ
 import corner_table
 import numpy as np
@@ -12,28 +13,30 @@
 class PrioritizedTri:
     area: float
     tri: Any=field(compare=False)
-    index: Any=field(compare=False)
 
-    def __init__(self, idx, tri, verts) -> None:
-        a = length(np.asarray(verts[tri[0]-1]) - np.asarray(verts[tri[1]-1]))
-        b = length(np.asarray(verts[tri[1]-1]) - np.asarray(verts[tri[2]-1]))
-        c = length(np.asarray(verts[tri[2]-1]) - np.asarray(verts[tri[0]-1]))
+    def __init__(self, idx, tri, verts, priority=None) -> None:
+        if priority != None:
+            self.area = priority
+        else:
+            a = length(np.asarray(verts[tri[0]-1]) - np.asarray(verts[tri[1]-1]))
+            b = length(np.asarray(verts[tri[1]-1]) - np.asarray(verts[tri[2]-1]))
+            c = length(np.asarray(verts[tri[2]-1]) - np.asarray(verts[tri[0]-1]))
 
-        # semi-perimeter of the circle
-        p = (a + b + c) / 2
-    
-        # area of triangle
-        At = np.sqrt(p * (p - a) * (p - b) * (p - c))
-    
-        # area of the circle
-        A = 3.14 * pow(((a * b * c) / (4 * At)), 2)
+            # semi-perimeter of the circle
+            p = (a + b + c) / 2
         
-        #priority queue is lower first, so negative value of area to fix that
-        self.area = -A
+            # area of triangle
+            At = np.sqrt(p * (p - a) * (p - b) * (p - c))
+        
+            # area of the circle
+            A = 3.14 * pow(((a * b * c) / (4 * At)), 2)
+            
+            #priority queue is lower first, so negative value of area to fix that
+            self.area = -A
         self.tri = tri
-        self.index = idx
-
 
+    def index(self, faces):
+        return faces.index(self.tri) + 1
 
 def length(v):
     return np.sqrt(np.dot(v, v))
@@ -41,8 +44,11 @@ def length(v):
 def angle(a,b):
     return np.arccos(np.dot(a,b) / (length(a) * length(b)))
 
-def met_req(tri, faces, verts):
-    #TODO: verificar se ângulo é formado por arestas de restrição
+def met_req(tri, faces, verts, arestas_restritas, h):
+    #verificar se ângulo é formado por arestas de restrição
+    if (tri[0], tri[1]) in arestas_restritas or (tri[1], tri[0]) in arestas_restritas or (tri[1], tri[2]) in arestas_restritas or (tri[2], tri[1]) in arestas_restritas or (tri[2], tri[0]) in arestas_restritas or (tri[0], tri[2]) in arestas_restritas:
+        return True
+
     a = np.asarray(verts[tri[0]-1]) - np.asarray(verts[tri[1]-1])
     b = np.asarray(verts[tri[1]-1]) - np.asarray(verts[tri[2]-1])
     c = np.asarray(verts[tri[2]-1]) - np.asarray(verts[tri[0]-1])
@@ -52,12 +58,46 @@ def met_req(tri, faces, verts):
     angleCA = angle(c,a)
 
     #podia ser 28.6
-    if 30 <= angleAB and 30 <= angleBC and 30 <= angleCA:
+    if 30 <= angleAB and 30 <= angleBC and 30 <= angleCA and min([length(a), length(b), length(c)]) < h:
         return True
     return False
 
-def user_defined():
-    return True
+def border(aresta, faces, verts, corners):
+    pi,pj = aresta
+    for f in faces:
+        pk = np.delete(f, np.where(np.asarray(f)==aresta[0]))
+        pk = list(np.delete(pk, np.where(pk==aresta[1])))
+        if len(pk) == 1:
+            pk = pk[0]
+            cs = delaunay.find_tri_corners(faces.index(f), corners)
+            for c in cs:
+                if c.c_o==-1:
+                    return True, [pi,pj,pk]
+    return False, [pi,pj,pk]
+
+def user_defined(arestas_restritas, h, faces, verts, corners):
+    #TODO limitar o tamanho das arestas de borda entre h e raiz de 3h
+    # edges = delaunay.find_edges(faces)
+    # edges_length = [length(x) for x in [np.asarray(verts[y[0]-1]) - verts[y[1]-1] for y in edges]]
+    # h = min(edges_length)
+    for aresta in arestas_restritas:
+        bord, tri = border(aresta, faces, verts, corners)
+        if bord:
+            if length(np.asarray(verts[aresta[0]-1])- verts[aresta[1]-1]) > h:
+                arestas_restritas.remove(aresta)
+                meio = np.asarray(verts[aresta[1]-1]) + (np.asarray(verts[aresta[0]-1])- np.asarray(verts[aresta[1]-1]))/2
+                verts.append(meio)
+
+                faces.pop(delaunay.find_tri_index(tri,faces))
+                faces.append([aresta[0], tri[2], len(verts)])
+                faces.append([len(verts), tri[2], aresta[1]])
+                
+                corners = corner_table.build_corner_table(faces)
+
+                arestas_restritas.append([aresta[0],len(verts)])
+                arestas_restritas.append([len(verts),aresta[1]])
+
+    return corners
 
 def circumcenter(a, b, c):
     d = 2 * (a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1]))
@@ -70,57 +110,78 @@ def inside_triangulation(pr, tri, faces, verts, corners, ax):
     b = verts[tri.tri[1]-1]
     c = verts[tri.tri[2]-1]
 
-    cs = delaunay.find_tri_corners(tri.index-1, corners)
+    cs = delaunay.find_tri_corners(tri.index(faces)-1, corners)
     border = False
     for corner in cs:
         if corner.c_o == -1:
             border = True
             break
 
-    if border and not delaunay.inside(pr, verts, corners, faces)[0]:
-        distAB = length(np.asarray(a) + ((np.asarray(b) - np.asarray(a))/2) - np.asarray(pr))
-        distBC = length(np.asarray(b) + ((np.asarray(c) - np.asarray(b))/2) - np.asarray(pr))
-        distCA = length(np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2) - np.asarray(pr))
-
-        if distAB < distBC:
-            if distAB < distCA:
-                #AB é menor retorna o ponto médio
-                 return False, np.asarray(a) + ((np.asarray(b) - np.asarray(a))/2)
+    #TODO verificar se tamanho da aresta esta entre h e (raiz de 3)*h, se estiver maior divide, se tiver no range ignora
+    if not delaunay.inside(pr, verts, corners, faces)[0]:
+        if not border: # se circuncentro não é visível
+            return False, pr
+        else:
+            distAB = length(np.asarray(a) + ((np.asarray(b) - np.asarray(a))/2) - np.asarray(pr))
+            distBC = length(np.asarray(b) + ((np.asarray(c) - np.asarray(b))/2) - np.asarray(pr))
+            distCA = length(np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2) - np.asarray(pr))
+
+            if distAB < distBC:
+                if distAB < distCA:
+                    #AB é menor retorna o ponto médio
+                    return True, np.asarray(a) + ((np.asarray(b) - np.asarray(a))/2)
+                else:
+                    #CA é menor retorna o ponto médio
+                    return True, np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2)
+            elif distBC < distCA:
+                #BC é menor retorna o ponto médio
+                return True, np.asarray(b) + ((np.asarray(c) - np.asarray(b))/2)
             else:
                 #CA é menor retorna o ponto médio
-                return False, np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2)
-        elif distBC < distCA:
-            #BC é menor retorna o ponto médio
-            return False, np.asarray(b) + ((np.asarray(c) - np.asarray(b))/2)
-        else:
-            #CA é menor retorna o ponto médio
-            return False, np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2)
+                return True, np.asarray(c) + ((np.asarray(a) - np.asarray(c))/2)
     return True, pr
 
-def chew(faces, corners, verts, ax1, arestas_restritas):    
+def chew(faces, corners, verts, ax1, arestas_restritas, h):    
     q = queue.PriorityQueue()
     
-
-    for idx, tri in enumerate(faces):
-        if not (met_req(tri, faces, verts) and user_defined()):
-            q.put(PrioritizedTri(idx+1, tri, verts))
+    corners = user_defined(arestas_restritas, h, faces, verts, corners)
+    for tri in faces:
+        if not met_req(tri, faces, verts, arestas_restritas, h):
+            q.put(PrioritizedTri(faces.index(tri)+1, tri, verts))
 
     while not q.empty():
         plot_tri(faces.copy(), verts.copy(), ax1)
         tri = q.get()
-
+        if tri.tri not in faces:
+            continue
+        if met_req(tri,faces,verts,arestas_restritas,h):
+            continue
+        
         pr = circumcenter(verts[tri.tri[0]-1], verts[tri.tri[1]-1], verts[tri.tri[2]-1])
 
         ax1.scatter(pr[0], pr[1], color='b')
         plt.pause(0.05)
 
-        inside, pr = inside_triangulation(pr, tri, faces.copy(), verts, corners, ax1)
+        should_add_point, pr = inside_triangulation(pr, tri, faces.copy(), verts, corners, ax1)
+        
+        if not should_add_point:
+            continue
+
+        ax1.scatter(pr[0], pr[1], color='g')
+        plt.pause(0.05)
+        if len(verts) == 65:
+            print('a')
+        #TODO divide a aresta só se ela for visivel se inside = false
+        corners, faces = delaunay.add_point(pr, verts, corners, faces, arestas_restritas, h)
 
-        corners, faces = delaunay.add_point(pr, verts, corners, faces, arestas_restritas)
+        #TODO fazer o critério de parada
+
+        #TODO vertice 56 ta com problema
+        
         added_tris = [x for x in faces if len(verts) in x]
         for t in added_tris:
-            if not met_req(t,faces,verts):
-                q.put(PrioritizedTri(faces.index(t), t, verts))
+            if not met_req(t,faces, verts, arestas_restritas, h):
+                q.put(PrioritizedTri(faces.index(t)+1, t, verts))
         # ax1.triplot(np.asarray(verts)[:,0], np.asarray(verts)[:,1], triangles = np.asarray(T[-3:])-1, color='r')
             
     return faces, corners, verts
@@ -145,14 +206,16 @@ def main ():
         if obj.name != "small_disk.obj":
             continue
         corners = corner_table.build_corner_table(obj.faces)
-        l = input().rstrip().split(',') # entrada:v1,v2,v3,v4
-        if len(l) > 1:
-            arestas.append(list(map(int,l)))
-            arestas = [tuple(x) for x in np.asarray(arestas).reshape(-1,2)]
+        with open("arestas.in", 'r') as f: 
+            l = f.readline().rstrip().split(',') # entrada:v1,v2,v3,v4
+            h = float(f.readline().rstrip())
+            if len(l) > 1:
+                arestas.append(list(map(int,l)))
+                arestas = [tuple(x) for x in np.asarray(arestas).reshape(-1,2)]
 
         faces, corners, verts = delaunay.delaunay_triangulation(obj, arestas, ax1)
         faces, corners, verts = delaunay.delaunay_restriction(faces, corners, arestas, verts, ax1)
-        faces, corners, verts = chew(faces, corners, verts, ax1, arestas)
+        faces, corners, verts = chew(faces, corners, verts, ax1, arestas, h)
         plt.show()
 
 if __name__ == '__main__':
diff --git a/delaunay.py b/delaunay.py
index 9c2af60..b409a6b 100644
--- a/delaunay.py
+++ b/delaunay.py
@@ -10,6 +10,9 @@
 import convex
 import queue
 
+def length(v):
+    return np.sqrt(np.dot(v, v))
+
 def find_tri_corners(idx, corners):
     return [corners[3*idx], corners[corners[3*idx].c_n - 1], corners[corners[3*idx].c_p - 1]]
 
@@ -25,17 +28,20 @@ def inside(pr, verts, corners, T, tri=None):
         b = [1, pr[0], pr[1]]
 
         x = np.linalg.solve(A,b)
-        if abs(x[0]) < 5e-3:
+        #TODO pode ter problema aqui
+        if (x < 0).any():
+            continue
+        elif abs(x[0]) < 1e-3:
             #v2 e v3
             return False, tri, [tri[1], tri[2]]
-        elif abs(x[1]) < 5e-3:
+        elif abs(x[1]) < 1e-3:
             #v3 e v1
             return False, tri, [tri[2], tri[0]]
-        elif abs(x[2]) < 5e-3:
+        elif abs(x[2]) < 1e-3:
             #v1 e v2
             return False, tri, [tri[0], tri[1]]
         elif (x > 0).all():
-            return True, tri, []
+            return True, tri, min(x)
             
     return False, [], []
 
@@ -110,7 +116,7 @@ def plot_tri(faces, vertex, ax1):
     ax1.triplot(vertex[:,0], vertex[:,1], triangles = faces, color='k')
     plt.pause(0.05)
 
-def add_point(pr, verts, corners, T, arestas_restritas):
+def add_point(pr, verts, corners, T, arestas_restritas, h=0):
     # plot_tri(T.copy(), verts.copy(), ax1)
 
     # ax1.scatter(pr[0],pr[1],color='r')
@@ -134,6 +140,9 @@ def add_point(pr, verts, corners, T, arestas_restritas):
         corners = legalize_aresta(pr, [pj,pk], arestas_restritas, t2, T, corners, verts)
         corners = legalize_aresta(pr, [pk,pi], arestas_restritas, t3, T, corners, verts)
     elif len(aresta) == 2:
+        if tuple(aresta) in arestas_restritas and length(np.asarray(aresta[0]) - np.asarray(aresta[1])) <= np.sqrt(3)*h:
+            return corners
+
         verts.append(list(pr))
         pr = len(verts)
 
@@ -167,6 +176,9 @@ def add_point(pr, verts, corners, T, arestas_restritas):
         
             corners = corner_table.build_corner_table(T)
 
+            corners = legalize_aresta(pr, [pk,pi], arestas_restritas, t1, T, corners, verts)
+            corners = legalize_aresta(pr, [pj,pk], arestas_restritas, t2, T, corners, verts)
+
         else:
             t1 = [pj, pk, pr]
             t2 = [pk, pi, pr]

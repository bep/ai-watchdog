diff --git a/__pycache__/convex.cpython-39.pyc b/__pycache__/convex.cpython-39.pyc
new file mode 100644
index 0000000..a36f501
Binary files /dev/null and b/__pycache__/convex.cpython-39.pyc differ
diff --git a/__pycache__/corner_table.cpython-38.pyc b/__pycache__/corner_table.cpython-38.pyc
new file mode 100644
index 0000000..ef1dbf4
Binary files /dev/null and b/__pycache__/corner_table.cpython-38.pyc differ
diff --git a/__pycache__/corner_table.cpython-39.pyc b/__pycache__/corner_table.cpython-39.pyc
index f0cd3d8..fcb3e12 100644
Binary files a/__pycache__/corner_table.cpython-39.pyc and b/__pycache__/corner_table.cpython-39.pyc differ
diff --git a/__pycache__/intersect_edges.cpython-38.pyc b/__pycache__/intersect_edges.cpython-38.pyc
new file mode 100644
index 0000000..5f485a3
Binary files /dev/null and b/__pycache__/intersect_edges.cpython-38.pyc differ
diff --git a/__pycache__/intersect_edges.cpython-39.pyc b/__pycache__/intersect_edges.cpython-39.pyc
new file mode 100644
index 0000000..894e007
Binary files /dev/null and b/__pycache__/intersect_edges.cpython-39.pyc differ
diff --git a/__pycache__/obj.cpython-38.pyc b/__pycache__/obj.cpython-38.pyc
new file mode 100644
index 0000000..3779b8d
Binary files /dev/null and b/__pycache__/obj.cpython-38.pyc differ
diff --git a/__pycache__/obj.cpython-39.pyc b/__pycache__/obj.cpython-39.pyc
index be180df..d119d31 100644
Binary files a/__pycache__/obj.cpython-39.pyc and b/__pycache__/obj.cpython-39.pyc differ
diff --git a/arestas.in b/arestas.in
index c1de6b4..f519ab8 100644
--- a/arestas.in
+++ b/arestas.in
@@ -1 +1 @@
-10,7,8,19
\ No newline at end of file
+10,22
\ No newline at end of file
diff --git a/convex.py b/convex.py
new file mode 100644
index 0000000..2c1625c
--- /dev/null
+++ b/convex.py
@@ -0,0 +1,79 @@
+# Python3 program to implement
+# the above approach
+
+# Utility function to find cross product
+# of two vectors
+def CrossProduct(A):
+	
+	# Stores coefficient of X
+	# direction of vector A[1]A[0]
+	X1 = (A[1][0] - A[0][0])
+
+	# Stores coefficient of Y
+	# direction of vector A[1]A[0]
+	Y1 = (A[1][1] - A[0][1])
+
+	# Stores coefficient of X
+	# direction of vector A[2]A[0]
+	X2 = (A[2][0] - A[0][0])
+
+	# Stores coefficient of Y
+	# direction of vector A[2]A[0]
+	Y2 = (A[2][1] - A[0][1])
+
+	# Return cross product
+	return (X1 * Y2 - Y1 * X2)
+
+# Function to check if the polygon is
+# convex polygon or not
+def isConvex(points):
+	
+	# Stores count of
+	# edges in polygon
+	N = len(points)
+
+	# Stores direction of cross product
+	# of previous traversed edges
+	prev = 0
+
+	# Stores direction of cross product
+	# of current traversed edges
+	curr = 0
+
+	# Traverse the array
+	for i in range(N):
+		
+		# Stores three adjacent edges
+		# of the polygon
+		temp = [points[i], points[(i + 1) % N],
+						points[(i + 2) % N]]
+
+		# Update curr
+		curr = CrossProduct(temp)
+
+		# If curr is not equal to 0
+		if (curr != 0):
+			
+			# If direction of cross product of
+			# all adjacent edges are not same
+			if (curr * prev < 0):
+				return False
+			else:
+				
+				# Update curr
+				prev = curr
+
+	return True
+
+# Driver code
+if __name__ == '__main__':
+	
+	points = [ [ 0, 0 ], [ 0, 1 ],
+			[ 1, 1 ], [ 1, 0 ] ]
+
+	if (isConvex(points)):
+		print("Yes")
+	else:
+		print("No")
+
+# This code is contributed by SURENDRA_GANGWAR
diff --git a/corner_table.py b/corner_table.py
index 88a1db1..2ab7fce 100644
--- a/corner_table.py
+++ b/corner_table.py
@@ -2,7 +2,7 @@
 import numpy as np
 import matplotlib.pyplot as plt
 import obj as OBJ
-from tqdm import tqdm
+# from tqdm import tqdm
 import cProfile
 import pstats
 
@@ -24,7 +24,7 @@ def find_tri_corners(idx, corners):
     return [corners[3*idx], corners[corners[3*idx].c_n - 1], corners[corners[3*idx].c_p - 1]]
 
 def find_opposite(corners, faces):
-    for corner in tqdm(corners):
+    for corner in corners:
         if corner.c_o != -1:
             continue
 
diff --git a/delaunay.py b/delaunay.py
index f4dbbfe..8a62541 100644
--- a/delaunay.py
+++ b/delaunay.py
@@ -1,10 +1,14 @@
 import os
 import numpy as np
 import matplotlib.pyplot as plt
+from numpy.lib.function_base import insert
 import obj as OBJ
 import corner_table
 from itertools import permutations
 from math import sqrt
+import intersect_edges
+import convex
+import queue
 
 fig1, ax1 = plt.subplots()
 ax1.set_aspect('equal')
@@ -83,7 +87,7 @@ def legalize_aresta(pr, aresta, arestas_restritas, t, T, corners, verts):
         return corners
         
     # TODO: muda restrição para depois da criação da triangulação, paper: a fast algorithm for generating constrained delaunay triangulations. S. W. Sloan
-    if aresta_ilegal(aresta, t, pl, verts) and not (tuple(aresta) in arestas_restritas or tuple([aresta[1],aresta[0]]) in arestas_restritas) or in_circle(aresta, verts):
+    if aresta_ilegal(aresta, t, pl, verts) and not (tuple(aresta) in arestas_restritas or tuple([aresta[1],aresta[0]]) in arestas_restritas):
         pi, pj = aresta
         pk = pl
         T.remove(t)
@@ -197,22 +201,165 @@ def delaunay_triangulation(obj, arestas_restritas):
             corners = legalize_aresta(pr, [pi, pl], arestas_restritas, t3, T, corners, verts)
             corners = legalize_aresta(pr, [pl, pj], arestas_restritas, t4, T, corners, verts) 
     # plot_tri(T.copy(), verts.copy())
-    copy_T = T.copy()
+    #Remove supertriangle
+    # copy_T = T.copy()
+    # for t in copy_T:
+    #     if 1 in t:
+    #         T.remove(t)
+    #         continue
+    #     if 2 in t:
+    #         T.remove(t)
+    #         continue
+    #     if 3 in t:
+    #         T.remove(t)
+    #         continue
+    # plot_tri(T.copy(), verts.copy())
+    return T, corner_table.build_corner_table(T), verts
+
+def flip_aresta():
+    pass
+
+def find_vert_corners_opposite(vert, corners):
+    co = []
+    for c in corners:
+        if c.c_v == vert:
+            if c.c_o != -1:
+                co.append(c.c_o)
+    return co
+
+def find_intersecting_edges(edge, edges, verts):
+    int_edges = []
+    for e in edges:
+        if intersect_edges.doIntersect(verts[e[0]-1], verts[e[1]-1], verts[edge[0]-1], verts[edge[1]-1]):
+            if e[0] != edge[0] and e[0] != edge[1] and e[1] != edge[0] and e[1] != edge[1] and e[0] < e[1]:
+                int_edges.append(e)
+    return int_edges
+
+def find_edges(T):
+    edges = set()
+    for index, t in enumerate(T):
+        edges.add(tuple([t[0],t[1]]))
+        edges.add(tuple([t[1],t[2]]))
+        edges.add(tuple([t[2],t[0]]))
+    return edges
+
+def delaunay_restriction(faces, corners, restritas, verts):
+    edges = find_edges(faces)
+    for aresta in restritas:
+        arestas_novas = []
+        if aresta in edges:
+            continue
+        #achar arestas que intersectam
+        inter_edges = find_intersecting_edges(aresta, edges, verts)
+        
+        fila = queue.Queue()
+        for i in inter_edges:
+            fila.put(i)
+
+        while not fila.empty():
+            tri1 = []
+            tri2 = []
+            pk = 0
+            pl = 0
+            
+            i_edge = fila.get()
+            pi, pj = i_edge
+            insert_back = False
+            
+            #3.1
+            inter_edges.remove(i_edge)
+            
+            #3.2
+            for f_idx, f in enumerate(faces):
+                inter = np.intersect1d(f,i_edge)
+                
+                
+                pk = np.delete(f, np.where(f==i_edge[0]))
+                pk = list(np.delete(pk, np.where(pk==i_edge[1])))[0]
+                if len(inter) == 2 and ((inter == i_edge).all() or (inter == np.flip(i_edge)).all()):
+                    cs = find_tri_corners(f_idx, corners)
+                    for corner in cs:
+                        if corner.c_v not in i_edge:
+                            tri1 = faces[f_idx]
+                            tri2 = faces[corners[corner.c_o-1].c_t-1]
+                            pl = corners[corner.c_o-1].c_v
+                            a = verts[corner.c_v - 1]
+                            b = verts[corners[corner.c_n-1].c_v-1]
+                            c = verts[corners[corner.c_o-1].c_v-1]
+                            d = verts[corners[corner.c_p-1].c_v-1]
+
+                            if not convex.isConvex([ a,b,c,d ]):
+                                insert_back = True
+                                break
+                    break
+
+            if insert_back:
+                fila.put(i_edge)
+                continue
+            else:
+                #flipa aresta
+                faces.remove(tri1)
+                faces.remove(tri2)
+                faces.append([pi,pk,pl])
+                faces.append([pk,pj,pl])
+
+                corners = corner_table.build_corner_table(faces)
+
+                if intersect_edges.doIntersect(verts[pl-1], verts[pk-1], verts[aresta[0]-1], verts[aresta[1]-1]):
+                    if pl != aresta[0] and pl != aresta[1] and pk != aresta[0] and pk != aresta[1]:
+                        fila.put([pl,pk])
+                    else:
+                        arestas_novas.append([pl,pk])
+                else:
+                    arestas_novas.append([pl,pk])
+
+        #4.1
+        for idx, n_edge in enumerate(arestas_novas):
+            #4.2
+            if n_edge == list(aresta):
+                continue
+            pi, pj = n_edge
+            #4.3
+            for f_idx, f in enumerate(faces):
+                inter = np.intersect1d(f,aresta)
+                
+                
+                pk = np.delete(f, np.where(f==i_edge[0]))
+                pk = list(np.delete(pk, np.where(pk==i_edge[1])))[0]
+                if len(inter) == 2 and ((inter == i_edge).all() or (inter == np.flip(i_edge)).all()):
+                    cs = find_tri_corners(f_idx, corners)
+                    for c in cs:
+                        if c not in i_edge:
+                            pl = corners[c.c_o - 1].c_v
+            if aresta_ilegal(n_edge, [pi,pj,pk], pl, verts):
+                faces.remove([pi,pj,pk])
+                faces.remove(faces[find_tri_index([pi,pj,pl],faces)-1])
+                faces.append([pi,pk,pl])
+                faces.append([pk,pj,pl])
+                arestas_novas[idx] = [pk,pl]
+
+                corners = corner_table.build_corner_table(faces)
+
+    #remove supertriangle
+    copy_T = faces.copy()
     for t in copy_T:
         if 1 in t:
-            T.remove(t)
+            faces.remove(t)
             continue
         if 2 in t:
-            T.remove(t)
+            faces.remove(t)
             continue
         if 3 in t:
-            T.remove(t)
+            faces.remove(t)
             continue
-    plot_tri(T.copy(), verts.copy())
+    corners = corner_table.build_corner_table(faces)
+    plot_tri(faces.copy(), verts.copy())
     for idx,x in enumerate(verts):
         plt.text(x[0], x[1], str(idx+1),color='g')
-    plt.show(block=True)
-    return T
+    plt.show()
+    return faces, corners, verts
+
+            
 
 def main ():
     objs = OBJ.read_OBJ("./OBJ/")
@@ -225,7 +372,11 @@ def main ():
         arestas.append(list(map(int,l)))
         arestas = [tuple(x) for x in np.asarray(arestas).reshape(-1,2)]
 
-        faces = delaunay_triangulation(obj, arestas)
+        faces, corners, verts = delaunay_triangulation(obj, arestas)
+        faces, corners, verts = delaunay_restriction(faces, corners, arestas, verts)
+        
+        
+
 
 if __name__ == '__main__':
     main()
\ No newline at end of file
diff --git a/intersect_edges.py b/intersect_edges.py
new file mode 100644
index 0000000..57583e6
--- /dev/null
+++ b/intersect_edges.py
@@ -0,0 +1,73 @@
+# Given three collinear points p, q, r, the function checks if
+# point q lies on line segment 'pr'
+def onSegment(p, q, r):
+	if ( (q[0] <= max(p[0], r[0])) and (q[0] >= min(p[0], r[0])) and
+		(q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))):
+		return True
+	return False
+
+def orientation(p, q, r):
+	# to find the orientation of an ordered triplet (p,q,r)
+	# function returns the following values:
+	# 0 : Collinear points
+	# 1 : Clockwise points
+	# 2 : Counterclockwise
+	
+	# See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp/
+	# for details of below formula.
+	
+	val = (float(q[1] - p[1]) * (r[0] - q[0])) - (float(q[0] - p[0]) * (r[1] - q[1]))
+	if (val > 0):
+		
+		# Clockwise orientation
+		return 1
+	elif (val < 0):
+		
+		# Counterclockwise orientation
+		return 2
+	else:
+		
+		# Collinear orientation
+		return 0
+
+# The main function that returns true if
+# the line segment 'p1q1' and 'p2q2' intersect.
+def doIntersect(p1,q1,p2,q2):
+	
+	# Find the 4 orientations required for
+	# the general and special cases
+	o1 = orientation(p1, q1, p2)
+	o2 = orientation(p1, q1, q2)
+	o3 = orientation(p2, q2, p1)
+	o4 = orientation(p2, q2, q1)
+
+	# General case
+	if ((o1 != o2) and (o3 != o4)):
+		return True
+
+	# Special Cases
+
+	# p1 , q1 and p2 are collinear and p2 lies on segment p1q1
+	if ((o1 == 0) and onSegment(p1, p2, q1)):
+		return True
+
+	# p1 , q1 and q2 are collinear and q2 lies on segment p1q1
+	if ((o2 == 0) and onSegment(p1, q2, q1)):
+		return True
+
+	# p2 , q2 and p1 are collinear and p1 lies on segment p2q2
+	if ((o3 == 0) and onSegment(p2, p1, q2)):
+		return True
+
+	# p2 , q2 and q1 are collinear and q1 lies on segment p2q2
+	if ((o4 == 0) and onSegment(p2, q1, q2)):
+		return True
+
+	# If none of the cases
+	return False
+
+if __name__ == '__main__':
+    if doIntersect([0,0],[1,1],[0,1],[1,0]):
+        print("True")
+    else:
+        print("FALse")
\ No newline at end of file

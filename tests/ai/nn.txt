diff --git a/tests/ai/nn.py b/tests/ai/nn.py
new file mode 100644
index 0000000..b95aa1d
--- /dev/null
+++ b/tests/ai/nn.py
@@ -0,0 +1,107 @@
+import numpy as np
+from typing import List, Tuple
+
+class CodeClassifierNN:
+    def __init__(self, input_size: int, hidden_size: int = 128):
+        # Initialize weights and biases
+        self.input_size = input_size
+        self.hidden_size = hidden_size
+        self.output_size = 1  # Binary classification (0: human, 1: AI)
+        
+        # Xavier/Glorot initialization for better gradient flow
+        self.W1 = np.random.randn(self.input_size, self.hidden_size) * np.sqrt(2.0 / self.input_size)
+        self.b1 = np.zeros((1, self.hidden_size))
+        self.W2 = np.random.randn(self.hidden_size, self.output_size) * np.sqrt(2.0 / self.hidden_size)
+        self.b2 = np.zeros((1, self.output_size))
+
+    def sigmoid(self, x: np.ndarray) -> np.ndarray:
+        return 1 / (1 + np.exp(-np.clip(x, -500, 500)))
+    
+    def sigmoid_derivative(self, x: np.ndarray) -> np.ndarray:
+        return x * (1 - x)
+    
+    def preprocess_text(self, code: str) -> np.ndarray:
+        # Simple feature extraction: character frequency
+        features = np.zeros(128)  # ASCII characters
+        total_chars = len(code)
+        if total_chars == 0:
+            return features
+        
+        for char in code:
+            ascii_val = ord(char)
+            if ascii_val < 128:
+                features[ascii_val] += 1
+        
+        # Normalize features
+        return features / total_chars
+    
+    def forward(self, X: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
+        # Forward propagation
+        self.hidden = self.sigmoid(np.dot(X, self.W1) + self.b1)
+        self.output = self.sigmoid(np.dot(self.hidden, self.W2) + self.b2)
+        return self.hidden, self.output
+    
+    def backward(self, X: np.ndarray, y: np.ndarray, hidden: np.ndarray, output: np.ndarray, 
+                learning_rate: float = 0.01) -> None:
+        # Backward propagation
+        self.output_error = y - output
+        self.output_delta = self.output_error * self.sigmoid_derivative(output)
+        
+        self.hidden_error = np.dot(self.output_delta, self.W2.T)
+        self.hidden_delta = self.hidden_error * self.sigmoid_derivative(hidden)
+        
+        # Update weights and biases
+        self.W2 += learning_rate * np.dot(hidden.T, self.output_delta)
+        self.b2 += learning_rate * np.sum(self.output_delta, axis=0, keepdims=True)
+        self.W1 += learning_rate * np.dot(X.T, self.hidden_delta)
+        self.b1 += learning_rate * np.sum(self.hidden_delta, axis=0, keepdims=True)
+    
+    def train(self, code_samples: List[str], labels: List[int], epochs: int = 1000, 
+             learning_rate: float = 0.01) -> List[float]:
+        X = np.array([self.preprocess_text(code) for code in code_samples])
+        y = np.array(labels).reshape(-1, 1)
+        
+        losses = []
+        for epoch in range(epochs):
+            hidden, output = self.forward(X)
+            self.backward(X, y, hidden, output, learning_rate)
+            
+            # Calculate and store loss
+            loss = np.mean(np.square(y - output))
+            losses.append(loss)
+            
+            if epoch % 100 == 0:
+                print(f"Epoch {epoch}, Loss: {loss:.4f}")
+        
+        return losses
+    
+    def predict(self, code: str) -> float:
+        X = self.preprocess_text(code).reshape(1, -1)
+        _, output = self.forward(X)
+        return output[0, 0]
+
+# Example usage:
+if __name__ == "__main__":
+    # Example training data
+    code_samples = [
+        "def hello_world():\n    print('Hello, World!')",
+        "print('AI generated code example')",
+        # Add more samples...
+    ]
+    labels = [0, 1]  # 0: human-written, 1: AI-generated
+    
+    # Initialize and train the model
+    model = CodeClassifierNN(input_size=128)
+    losses = model.train(code_samples, labels)
+    
+    # Test the model
+    test_code = "def test_function():\n    return True"
+    prediction = model.predict(test_code)
+    print(f"Prediction (1 = AI, 0 = Human): {prediction:.4f}")